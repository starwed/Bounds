// Generated by CoffeeScript 1.9.0
(function() {
  var Bounds, Clamp, Crafty, FLUSH_SAVES, GLOBAL_PUSHED, GRAVITY, INSTRUCTIONS, INSTRUCTIONS2, Level, checkWin, configureTileGraphics, debugText, newPlayer, particleBackground, particleEffect, resetCollisions, resetMap, showDebugText, statusText;

  console.log("Bounds game");

  Crafty = window.Crafty;

  Clamp = function(x, a, b) {
    return Math.min(Math.max(x, a), b);
  };

  GLOBAL_PUSHED = null;

  GRAVITY = 0.2;

  statusText = null;

  debugText = null;

  showDebugText = null;

  resetMap = null;

  FLUSH_SAVES = false;

  INSTRUCTIONS = "<div>\n    <b>Arrows</b> move.<br/>\n    <b>Q</b> & <b>E</b> jump left & right.<br/>\n    <b>Down</b> slides off a ledge.<br/> \n    <br/>\n    <b>G</b> toggles grid.<br/>\n    <b>K</b> restarts.<br/>  \n    <b>Esc</b> for level select.\n</div>  ";

  INSTRUCTIONS2 = "<div>\n    <b>Arrows</b> move.<br/>\n    <b>Q</b> & <b>E</b> jump left & right.<br/>\n    <b>?</b> for more info.<br/> \n</div>  ";

  window.Bounds = Bounds = {
    dataVersion: 0.211,
    AUTO_ADVANCE: true,
    CURRENT_LEVEL: 1,
    storage: {},
    dbName: "Bounds0",
    player: {},
    gridVisibility: false,
    GRAVITY: GRAVITY,
    setStatus: function(msg) {
      return statusText.text(msg);
    },
    toggleGrid: function() {
      console.log("hey toggled");
      this.gridVisibility = !this.gridVisibility;
      return this.TheGrid.visible = this.gridVisibility;
    },
    advance: function(time, moves) {
      var l, lID, levA;
      l = Bounds.CURRENT_LEVEL;
      lID = window.Bounds.levels[l].url;
      if (Bounds.completion.levels[lID] != null) {
        levA = Bounds.completion.levels[lID];
      } else {
        levA = Bounds.completion.levels[lID] = {};
      }
      console.log("Completion to check " + moves + " moves in " + time + " s against (" + levA.m + " mv | " + levA.t + " s)");
      levA.passed = true;
      if (levA.m != null) {
        if (moves < levA.m) {
          console.log("updating move score");
          levA.m = moves;
          levA.t = time;
        } else if (1.0 * moves === 1.0 * levA.m && ((1.0 * time) < (1.0 * levA.t))) {
          console.log("updating time score only");
          levA.t = 1.0 * time;
        } else {
          console.log("WTF?");
          console.log("t: " + time + " vs. " + levA.t);
          console.log("m: " + moves + " vs. " + levA.m);
        }
      } else {
        console.log("no m?");
        levA.m = moves;
        levA.t = time;
      }
      Bounds.saveCompletion();
      Bounds.CURRENT_LEVEL++;
      if (Bounds.levels[Bounds.CURRENT_LEVEL]) {
        Bounds.sceneChangeQueued = false;
        console.log("About to load " + Bounds.CURRENT_LEVEL);
        return Crafty.scene("load " + Bounds.CURRENT_LEVEL);
      }
    },
    queueSceneChange: function(action, timeout) {
      var sceneChange;
      if (Bounds.sceneChangeQueued === true) {
        return;
      }
      Bounds.sceneChangeQueued = true;
      sceneChange = (function(_this) {
        return function() {
          if (Bounds.sceneChangeQueued === false) {
            return;
          }
          Bounds.sceneChangeQueued = false;
          return action();
        };
      })(this);
      return window.setTimeout(sceneChange, timeout);
    }
  };

  window.Level = Level = {
    start_time: NaN,
    level: null
  };

  window.Bounds = Bounds;

  Bounds.db = {
    getValue: function(key) {
      return $.jStorage.get(key, null);
    },
    setValue: function(key, val) {
      return $.jStorage.set(key, val);
    },
    deleteKey: function(key) {
      return $.jStorage.deleteKey(key);
    }
  };

  Bounds.loadCompletion = function() {
    var completionJSON, e, version;
    version = Bounds.db.getValue("dataVersion");
    console.log("Data version in store is " + version);
    if (Bounds.dataVersion > version || version === null || FLUSH_SAVES === true) {
      Bounds.db.deleteKey("completion");
      Bounds.db.setValue("dataVersion", Bounds.dataVersion);
    }
    completionJSON = Bounds.db.getValue("completion");
    if (completionJSON !== null) {
      try {
        return Bounds.completion = JSON.parse(completionJSON);
      } catch (_error) {
        e = _error;
        console.log("blech, choking on json completion");
        Bounds.completion = {
          levels: {}
        };
        return Bounds.saveCompletion();
      }
    } else {
      return Bounds.completion = {
        levels: {}
      };
    }
  };

  Bounds.saveCompletion = function() {
    console.log("Saving completion values");
    console.log("Saving: " + JSON.stringify(Bounds.completion));
    Bounds.db.setValue("completion", JSON.stringify(Bounds.completion));
    return console.log("Done saving");
  };

  newPlayer = function(start) {
    var p;
    p = Crafty.e("2D, Canvas, alienNorm, Collision, Ballistic, JumpMan, KeyboardMan, Slider, Solid, Platform").attr({
      x: start._x,
      y: start._y,
      w: 28,
      h: 24
    }).launch(0, 0).accelerate(0, GRAVITY)._sizeFeet();
    return p;
  };

  particleEffect = function(level) {
    var options, redness;
    redness = Math.min(1, level / 20);
    options = {
      startColour: [150 + 100 * redness, 200 * (1 - redness), 155 + 150 * (1 - redness), 1],
      startColourRandom: [0, 0, 0, 0],
      endColourRandom: [0, 0, 0, 0],
      endColour: [redness, 0, 255 * (1 - redness), .5],
      lifespan: 5,
      gravity: {
        x: 0,
        y: 0
      },
      fastMode: false,
      maxParticles: 5,
      angle: 0,
      angleRandom: 180,
      size: level,
      spread: 1
    };
    return Crafty.e("2D,Canvas,Particles, Movable").particles(options).attr({
      x: 100,
      y: 100
    });
  };

  particleBackground = function() {
    var options;
    options = {
      startColour: [50, 50, 200, 1],
      startColourRandom: [0, 0, 50, 0],
      endColour: [255, 255, 255, .8],
      endColourRandom: [0, 0, 0, .3],
      lifeSpan: 100,
      speed: .8,
      speedRandom: .2,
      gravity: {
        x: 0,
        y: 0
      },
      fastMode: false,
      maxParticles: 20,
      angle: 0,
      angleRandom: 180,
      size: 15,
      spread: 400,
      backgroundLayer: true
    };
    return Crafty.e("2D,Canvas,Particles, Movable").particles(options).attr({
      x: 500,
      y: 400,
      z: -100
    });
  };

  Bounds.playMap = function(level, glyph) {
    var boundMeter, boundMeterText, dead, instructionText, instructionToggle, jumpMeterText, min, pl, r2d, reactorUpdate, sec, secD, start, timeText, titleText, updateTime, updateTimeText2, updateUI, win_time;
    console.log("Playing map thingy");
    Level.level = level;
    Level.gems = Crafty("Gem").length;
    console.log("Playing map " + glyph);
    Bounds.level_complete = false;
    Bounds.sceneChangeQueued = false;
    Bounds.resetMap = function() {
      return Crafty.scene("load " + glyph);
    };
    debugText = Crafty.e("2D, DOM, Text").attr({
      x: 1000,
      y: 100,
      w: 200
    });
    debugText.text(" ").css({
      "color": "white"
    });
    statusText = Crafty.e("2D, DOM, Text, Movable").attr({
      x: 500,
      y: 100
    });
    statusText.text("");
    statusText.css({
      "color": "white"
    });
    statusText.textFont({
      size: "10pt"
    });
    pl = {};
    dead = false;
    win_time = false;
    r2d = 180 / Math.PI;
    showDebugText = function() {
      return;
      return debugText.text(this._x + "," + this._y + "; v:" + this._vx + "," + this._vy + "; a:" + this._ax + "," + this._ay + "; \nactive:" + this.active + "; g:" + this.grounded + "; Jumps:" + Bounds.player._boundFactor + "   \nGems:" + (Crafty('Gem').length) + "; \nFriction:" + Bounds.player._fx + "  Pushing:" + (Bounds.player.pushed != null));
    };
    start = Crafty(Crafty("PlayerStart")[0]);
    Bounds.player = newPlayer(start);
    pl = Bounds.player;
    Bounds.TheGrid = Crafty.e("OverlayGrid").attr({
      x: 0,
      y: 0,
      alpha: .4
    });
    Bounds.TheGrid.visible = Bounds.gridVisibility;
    Bounds.backdrop = Crafty.e("BackdropPicture").attr({
      x: 0,
      y: 0,
      alpha: 1,
      z: -100
    });
    reactorUpdate = function() {
      return;
      this.unglue(this.parts);
      this.parts.destroy();
      this.parts = particleEffect(this._boundFactor);
      return this.glue(this.parts, 14 - this._boundFactor / 2, 12);
    };
    Level.start_time = (new Date).getTime();
    Bounds.player.bind("EnterFrame", checkWin);

    /*thing = Crafty.e("2D, Canvas, Sprite, topBlock1")
    thing.x = 100
    thing.y = 300
    thing.w=32
    thing.h=32
    thing.addComponent("topBlock1")
     */
    Bounds.player.glue(statusText, 0, -50);
    boundMeter = Crafty.e("2D, DOM, Color").color("#BB0000").attr({
      x: 1000,
      y: 600 - 32,
      h: 32,
      w: 32
    }).css({
      "box-shadow": "0px 0px 5px violet inset",
      "border-top-left-radius": "15px",
      "border-bottom-right-radius": "0px"
    }).bind("EnterFrame", function() {
      this.h = Bounds.player._boundFactor * 32;
      return this.y = 600 - this.h;
    });
    boundMeterText = Crafty.e("UIText").attr({
      x: 1000,
      y: 605
    });
    jumpMeterText = Crafty.e("UIText").attr({
      x: 1100,
      y: 605,
      w: 100
    });
    updateTimeText2 = function() {
      var current_time, time;
      if (Bounds.level_complete) {
        return;
      }
      current_time = (new Date()).getTime();
      time = new Date(current_time - Level.start_time);
      return this.text("Time: " + (time.getMinutes()) + ":" + (time.getSeconds()) + "." + (Math.floor(time.getMilliseconds() / 100)));
    };
    timeText = Crafty.e("UIText").attr({
      x: 1100,
      y: 585,
      w: 100
    });
    updateUI = function() {
      boundMeterText.text(Bounds.player._boundFactor);
      jumpMeterText.text("Moves: " + Bounds.player.jumps);
      boundMeter.h = Bounds.player._boundFactor * 32;
      return boundMeter.y = 600 - boundMeter.h;
    };
    boundMeter.bind("UpdateBoundmeter", updateUI);
    Bounds.level_time = 0;
    min = 0;
    sec = 0;
    secD = 0;
    updateTime = function(data) {
      var time;
      Bounds.level_time += data.dt;
      if (!Bounds.level_complete) {
        time = Bounds.level_time / 1000;
        min = (time / 60) | 0;
        sec = (time - 60 * min) | 0;
        secD = (time - 60 * min - sec) * 10 | 0;
        return timeText.text("Time: " + min + ":" + sec + "." + secD);
      }
    };
    timeText.bind("EnterFrame", updateTime);
    titleText = Crafty.e("UIText").attr({
      x: 100,
      y: 10,
      w: 400
    }).css({
      "font-size": "30pt"
    }).textFont({
      size: "30pt"
    }).text((glyph + 1) + ". " + level.name);
    instructionText = Crafty.e("2D, DOM, HTML, Mouse").attr({
      x: 1000,
      y: 55,
      w: 198,
      visible: false
    }).append("" + INSTRUCTIONS).css({
      'font-family': 'Helvetica, Arial',
      'text-align': 'right',
      'font-size': '12pt',
      'color': 'white',
      'width': '400',
      'visibility': 'hidden'
    });
    instructionText._visible = false;
    instructionToggle = Crafty.e("2D, Canvas, Mouse, Keyboard, questionmark").attr({
      x: 1170,
      y: 10,
      w: 30,
      h: 30
    }).bind("Click", function() {
      return instructionText.visible = !instructionText.visible;
    }).bind("KeyDown", function(e) {
      if (e.key === 191) {
        return instructionText.visible = !instructionText.visible;
      }
    });
    instructionText.visible = false;

    /*toggleText = Crafty.e("UIText").attr({ x: 1170 + 10, y: 10 + 10 })
        .text("?")
        .textColor('#000000', 1)
     */
    return configureTileGraphics();
  };

  configureTileGraphics = function() {
    var adjEmptyTiles, ent, id, pos, testBlock, testBlock2, tiles, _i, _j, _len, _len1, _ref, _results;
    tiles = Crafty("MapTile");
    console.log("fixing tiles now");
    testBlock = function(e, pos) {
      var e2;
      e2 = e.findRelativeTile(pos[0], pos[1]);
      if (e2 !== null) {
        if ((e2 != null ? e2.mapTileType : void 0) === e.mapTileType) {
          return 0;
        } else {
          return 1;
        }
      } else {
        return -1000;
      }
    };
    testBlock2 = function(e, pos) {
      var e2;
      e2 = e.findRelativeTile(pos);
      if (e2 !== void 0) {
        return true;
      } else {
        return false;
      }
    };
    _results = [];
    for (_i = 0, _len = tiles.length; _i < _len; _i++) {
      id = tiles[_i];
      ent = Crafty(id);
      if (ent.mapTileType === 1) {
        adjEmptyTiles = 0;
        _ref = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          pos = _ref[_j];
          adjEmptyTiles += testBlock(ent, pos);
        }
        if (adjEmptyTiles > 0) {
          ent.addComponent("edgeMetal");
        } else if (adjEmptyTiles < 0) {
          ent.addComponent("edgeMetal");
        } else {
          ent.removeComponent("Solid").removeComponent("Platform").removeComponent("Collision").addComponent("innerMetal");
        }
      }
      if (ent.has("CrumbleBrick")) {
        _results.push(ent.addComponent("gbM"));

        /*if ent.findRelativeTile("left") isnt undefined 
            if ent.findRelativeTile("right") isnt undefined
                ent.addComponent("gbM")
            else
                ent.addComponent("gbR")
        
        else
            ent.addComponent("gbL")
         */
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  resetCollisions = function() {
    var boxes, ent, id, poly, _i, _len, _results;
    boxes = Crafty("Collision");
    _results = [];
    for (_i = 0, _len = boxes.length; _i < _len; _i++) {
      id = boxes[_i];
      ent = Crafty(id);
      poly = new Crafty.polygon([0, 0, ent._w, 0, ent._w, ent._h, 0, ent._h]);
      _results.push(ent.collision(poly));
    }
    return _results;
  };

  checkWin = function() {
    var advanceLevel, e, level, win_moves, win_time;
    if (Bounds.player.grounded && Crafty('Gem').length === 0 && Bounds.player.dead === false && Bounds.level_complete === false) {
      level = Level.level;
      statusText.text("All gems collected!");
      Bounds.level_complete = true;
      win_time = Math.floor(Bounds.level_time / 100) / 10;
      win_moves = Bounds.player.jumps;
      try {
        console.log("Checking time as " + win_moves + " in " + win_time + " against " + level.par.m + "/" + level.par.t + " ");
      } catch (_error) {
        e = _error;
        console.log(e);
      }
      if (level.par != null) {
        if (win_time <= level.par.t && win_moves <= level.par.m) {
          statusText.text("Very efficient!");
        } else if (win_time > 300 || win_moves > 20) {
          statusText.text("Finally...");
        }
      }
      advanceLevel = function() {
        return Bounds.advance(win_time, win_moves);
      };
      return Bounds.queueSceneChange(advanceLevel, 1000);
    }
  };

}).call(this);
